(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["xtemplate/runtime"] = factory();
	else
		root["xtemplate/runtime"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// http://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
// http://wonko.com/post/html-escaping

const escapeHtml = __webpack_require__(5);

const SUBSTITUTE_REG = /\\?\{([^{}]+)\}/g;
const win = typeof global !== 'undefined' ? global : window;

let util;
const toString = Object.prototype.toString;
module.exports = util = {
  isArray: Array.isArray || function isArray(obj) {
    return toString.call(obj) === '[object Array]';
  },

  keys: Object.keys || function keys(o) {
    const result = [];
    let p;

    for (p in o) {
      if (o.hasOwnProperty(p)) {
        result.push(p);
      }
    }

    return result;
  },

  each(object, fn, context = null) {
    if (object) {
      let key;
      let val;
      let keys;
      let i = 0;
      const length = object && object.length;
      // do not use typeof obj == 'function': bug in phantomjs
      const isObj = length === undefined || Object.prototype.toString.call(object) === '[object Function]';

      if (isObj) {
        keys = util.keys(object);
        for (; i < keys.length; i++) {
          key = keys[i];
          // can not use hasOwnProperty
          if (fn.call(context, object[key], key, object) === false) {
            break;
          }
        }
      } else {
        for (val = object[0]; i < length; val = object[++i]) {
          if (fn.call(context, val, i, object) === false) {
            break;
          }
        }
      }
    }
    return object;
  },

  mix(t, s) {
    if (s) {
      for (const p in s) {
        if (s.hasOwnProperty(p)) {
          t[p] = s[p];
        }
      }
    }
    return t;
  },

  globalEval(data) {
    if (win.execScript) {
      win.execScript(data);
    } else {
      /* eslint wrap-iife:0 */
      (function run(d) {
        win.eval.call(win, d);
      })(data);
    }
  },

  substitute(str, o, regexp) {
    if (typeof str !== 'string' || !o) {
      return str;
    }

    return str.replace(regexp || SUBSTITUTE_REG, (match, name) => {
      if (match.charAt(0) === '\\') {
        return match.slice(1);
      }
      return o[name] === undefined ? '' : o[name];
    });
  },

  escapeHtml,

  merge(...args) {
    let i = 0;
    const len = args.length;
    const ret = {};
    for (; i < len; i++) {
      const arg = args[i];
      if (arg) {
        util.mix(ret, arg);
      }
    }
    return ret;
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/**
 * scope resolution for xtemplate like function in javascript but keep original data unmodified
 */

function Scope(data, affix, parent) {
  if (data !== undefined) {
    this.data = data;
  } else {
    this.data = {};
  }
  if (parent) {
    this.parent = parent;
    this.root = parent.root;
  } else {
    this.parent = undefined;
    this.root = this;
  }
  this.affix = affix || {};
  this.ready = false;
}

Scope.prototype = {
  isScope: 1,

  constructor: Scope,

  setParent(parentScope) {
    this.parent = parentScope;
    this.root = parentScope.root;
  },

  // keep original data unmodified
  set(name, value) {
    this.affix[name] = value;
  },

  setData(data) {
    this.data = data;
  },

  getData() {
    return this.data;
  },

  mix(v) {
    const affix = this.affix;
    for (const name in v) {
      if (v.hasOwnProperty(name)) {
        affix[name] = v[name];
      }
    }
  },

  get(name) {
    const data = this.data;
    let v;
    const affix = this.affix;

    if (data !== null && data !== undefined) {
      v = data[name];
    }

    if (v !== undefined) {
      return v;
    }

    return affix[name];
  },

  resolveInternalOuter(parts) {
    const part0 = parts[0];
    let v;
    const self = this;
    let scope = self;
    if (part0 === 'this') {
      v = self.data;
    } else if (part0 === 'root') {
      scope = scope.root;
      v = scope.data;
    } else if (part0) {
      /* eslint no-cond-assign:0 */
      do {
        v = scope.get(part0);
      } while (v === undefined && (scope = scope.parent));
    } else {
      return [scope.data];
    }
    return [undefined, v];
  },

  resolveInternal(parts) {
    const ret = this.resolveInternalOuter(parts);
    if (ret.length === 1) {
      return ret[0];
    }
    let i;
    const len = parts.length;
    let v = ret[1];
    if (v === undefined) {
      return undefined;
    }
    for (i = 1; i < len; i++) {
      if (v === null || v === undefined) {
        return v;
      }
      v = v[parts[i]];
    }
    return v;
  },

  resolveLooseInternal(parts) {
    const ret = this.resolveInternalOuter(parts);
    if (ret.length === 1) {
      return ret[0];
    }
    let i;
    const len = parts.length;
    let v = ret[1];
    for (i = 1; v !== null && v !== undefined && i < len; i++) {
      v = v[parts[i]];
    }
    return v;
  },

  resolveUp(parts) {
    return this.parent && this.parent.resolveInternal(parts);
  },

  resolveLooseUp(parts) {
    return this.parent && this.parent.resolveLooseInternal(parts);
  },

  resolveOuter(parts, d) {
    const self = this;
    let scope = self;
    let depth = d;
    let v;
    if (!depth && parts.length === 1) {
      v = self.get(parts[0]);
      if (v !== undefined) {
        return [v];
      }
      depth = 1;
    }
    if (depth) {
      while (scope && depth--) {
        scope = scope.parent;
      }
    }
    if (!scope) {
      return [undefined];
    }
    return [undefined, scope];
  },

  resolveLoose(parts, depth) {
    const ret = this.resolveOuter(parts, depth);
    if (ret.length === 1) {
      return ret[0];
    }
    return ret[1].resolveLooseInternal(parts);
  },

  resolve(parts, depth) {
    const ret = this.resolveOuter(parts, depth);
    if (ret.length === 1) {
      return ret[0];
    }
    return ret[1].resolveInternal(parts);
  }
};

module.exports = Scope;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * xtemplate runtime
 */
const util = __webpack_require__(0);
const nativeCommands = __webpack_require__(3);
const commands = {};
const Scope = __webpack_require__(1);
const LinkedBuffer = __webpack_require__(4);

// for performance: reduce hidden class
function TplWrap(name, runtime, root, scope, buffer, originalName, fn, parent) {
  this.name = name;
  this.originalName = originalName || name;
  this.runtime = runtime;
  this.root = root;
  // line counter
  this.pos = { line: 1 };
  this.scope = scope;
  this.buffer = buffer;
  this.fn = fn;
  this.parent = parent;
}

function findCommand(runtimeCommands, instanceCommands, parts) {
  const name = parts[0];
  let cmd = runtimeCommands && runtimeCommands[name] || instanceCommands && instanceCommands[name] || commands[name];
  if (parts.length === 1) {
    return cmd;
  }
  if (cmd) {
    const len = parts.length;
    for (let i = 1; i < len; i++) {
      cmd = cmd[parts[i]];
      if (!cmd) {
        return false;
      }
    }
  }
  return cmd;
}

function getSubNameFromParentName(parentName, subName) {
  const parts = parentName.split('/');
  const subParts = subName.split('/');
  parts.pop();
  for (let i = 0, l = subParts.length; i < l; i++) {
    const subPart = subParts[i];
    if (subPart === '.') {
      continue;
    } else if (subPart === '..') {
      parts.pop();
    } else {
      parts.push(subPart);
    }
  }
  return parts.join('/');
}

// depth: ../x.y() => 1
function callFn(tpl, scope, option, buffer, parts, depth) {
  let caller;
  let fn;
  let command1;
  if (!depth) {
    command1 = findCommand(tpl.runtime.commands, tpl.root.config.commands, parts);
  }
  if (command1) {
    return command1.call(tpl, scope, option, buffer);
  } else if (command1 !== false) {
    const callerParts = parts.slice(0, -1);
    caller = scope.resolve(callerParts, depth);
    if (caller === null || caller === undefined) {
      buffer.error(`Execute function \`${parts.join('.')}\` \
Error: ${callerParts.join('.')} is undefined or null`);
      return buffer;
    }
    fn = caller[parts[parts.length - 1]];
    if (fn) {
      // apply(x, undefined) error in ie8
      try {
        return fn.apply(caller, option.params || []);
      } catch (err) {
        buffer.error(`Execute function \`${parts.join('.')}\` Error: ${err.message}`);
        return buffer;
      }
    }
  }
  buffer.error(`Command Not Found: ${parts.join('.')}`);
  return buffer;
}

const utils = {
  callFn,

  // {{y().z()}}
  callDataFn(params, parts) {
    let caller = parts[0];
    let fn = caller;
    for (let i = 1; i < parts.length; i++) {
      const name = parts[i];
      if (fn && fn[name]) {
        caller = fn;
        fn = fn[name];
      } else {
        return '';
      }
    }
    return fn.apply(caller, params || []);
  },

  callCommand(tpl, scope, option, buffer, parts) {
    return callFn(tpl, scope, option, buffer, parts);
  }
};

/**
 * template file name for chrome debug
 *
 * @cfg {Boolean} name
 * @member XTemplate.Runtime
 */

/**
 * XTemplate runtime. only accept tpl as function.
 * @class XTemplate.Runtime
 */
function XTemplateRuntime(fn, config) {
  this.fn = fn;
  this.config = util.merge(XTemplateRuntime.globalConfig, config);
  this.subNameResolveCache = {};
  this.loadedSubTplNames = {};
}

util.mix(XTemplateRuntime, {
  Scope,

  LinkedBuffer,

  globalConfig: {},

  config(key, v) {
    const { globalConfig } = this;
    if (key !== undefined) {
      if (v !== undefined) {
        globalConfig[key] = v;
      } else {
        util.mix(globalConfig, key);
      }
    } else {
      return globalConfig;
    }
  },

  nativeCommands,

  utils,

  util,

  /**
   * add command to all template
   * @method
   * @static
   * @param {String} commandName
   * @param {Function} fn
   * @member XTemplate.Runtime
   */
  addCommand(commandName, fn) {
    commands[commandName] = fn;
  },

  /**
   * remove command from all template by name
   * @method
   * @static
   * @param {String} commandName
   * @member XTemplate.Runtime
   */
  removeCommand(commandName) {
    delete commands[commandName];
  }
});

function resolve(root, subName_, parentName) {
  let subName = subName_;
  if (subName.charAt(0) !== '.') {
    return subName;
  }
  const key = `${parentName}_ks_${subName}`;
  const nameResolveCache = root.subNameResolveCache;
  const cached = nameResolveCache[key];
  if (cached) {
    return cached;
  }
  subName = nameResolveCache[key] = getSubNameFromParentName(parentName, subName);
  return subName;
}

function loadInternal(root, name, runtime, scope, buffer, originalName, escape, parentTpl) {
  const tpl = new TplWrap(name, runtime, root, scope, buffer, originalName, undefined, parentTpl);
  buffer.tpl = tpl;
  root.config.loader.load(tpl, (error, tplFn_) => {
    let tplFn = tplFn_;
    if (typeof tplFn === 'function') {
      tpl.fn = tplFn;
      // reduce count of object field for performance
      /* eslint no-use-before-define:0 */
      renderTpl(tpl);
    } else if (error) {
      buffer.error(error);
    } else {
      tplFn = tplFn || '';
      if (escape) {
        buffer.writeEscaped(tplFn);
      } else {
        buffer.data += tplFn;
      }
      buffer.end();
    }
  });
}

function includeInternal(root, scope, escape, buffer, tpl, originalName) {
  const name = resolve(root, originalName, tpl.name);
  const newBuffer = buffer.insert();
  const next = newBuffer.next;
  loadInternal(root, name, tpl.runtime, scope, newBuffer, originalName, escape, buffer.tpl);
  return next;
}

function includeModuleInternal(root, scope, buffer, tpl, tplFn) {
  const newBuffer = buffer.insert();
  const next = newBuffer.next;
  const newTpl = new TplWrap(tplFn.TPL_NAME, tpl.runtime, root, scope, newBuffer, undefined, tplFn, buffer.tpl);
  newBuffer.tpl = newTpl;
  renderTpl(newTpl);
  return next;
}

function renderTpl(tpl) {
  const buffer = tpl.fn();
  // tpl.fn exception
  if (buffer) {
    const runtime = tpl.runtime;
    const extendTpl = runtime.extendTpl;
    let extendTplName;
    if (extendTpl) {
      extendTplName = extendTpl.params[0];
      if (!extendTplName) {
        return buffer.error('extend command required a non-empty parameter');
      }
    }
    const extendTplFn = runtime.extendTplFn;
    const extendTplBuffer = runtime.extendTplBuffer;
    // if has extend statement, only parse
    if (extendTplFn) {
      runtime.extendTpl = null;
      runtime.extendTplBuffer = null;
      runtime.extendTplFn = null;
      includeModuleInternal(tpl.root, tpl.scope, extendTplBuffer, tpl, extendTplFn).end();
    } else if (extendTplName) {
      runtime.extendTpl = null;
      runtime.extendTplBuffer = null;
      includeInternal(tpl.root, tpl.scope, 0, extendTplBuffer, tpl, extendTplName).end();
    }
    return buffer.end();
  }
}

function getIncludeScope(scope, option, buffer) {
  const params = option.params;
  if (!params[0]) {
    return buffer.error('include command required a non-empty parameter');
  }
  let newScope = scope;
  let newScopeData = params[1];
  const hash = option.hash;
  if (hash) {
    if (newScopeData) {
      newScopeData = util.mix({}, newScopeData);
    } else {
      newScopeData = {};
    }
    util.mix(newScopeData, hash);
  }
  // sub template scope
  if (newScopeData) {
    newScope = new Scope(newScopeData, undefined, scope);
  }
  return newScope;
}

function checkIncludeOnce(root, option, tpl) {
  const originalName = option.params[0];
  const name = resolve(root, originalName, tpl.name);
  const { loadedSubTplNames } = root;
  if (loadedSubTplNames[name]) {
    return false;
  }
  loadedSubTplNames[name] = true;
  return true;
}

XTemplateRuntime.prototype = {
  constructor: XTemplateRuntime,

  Scope,

  nativeCommands,

  utils,

  /**
   * remove command by name
   * @param commandName
   */
  removeCommand(commandName) {
    const config = this.config;
    if (config.commands) {
      delete config.commands[commandName];
    }
  },

  /**
   * add command definition to current template
   * @param commandName
   * @param {Function} fn command definition
   */
  addCommand(commandName, fn) {
    const config = this.config;
    config.commands = config.commands || {};
    config.commands[commandName] = fn;
  },

  include(scope, option, buffer, tpl) {
    return includeInternal(this, getIncludeScope(scope, option, buffer), option.escape, buffer, tpl, option.params[0]);
  },

  includeModule(scope, option, buffer, tpl) {
    return includeModuleInternal(this, getIncludeScope(scope, option, buffer), buffer, tpl, option.params[0]);
  },

  includeOnce(scope, option, buffer, tpl) {
    if (checkIncludeOnce(this, option, tpl)) {
      return this.include(scope, option, buffer, tpl);
    }
    return buffer;
  },

  includeOnceModule(scope, option, buffer, tpl) {
    if (checkIncludeOnce(this, option, tpl)) {
      return this.includeModule(scope, option, buffer, tpl);
    }
    return buffer;
  },

  /**
   * get result by merge data with template
   */
  render(data, option_, callback_) {
    let option = option_;
    let callback = callback_;
    let html = '';
    const fn = this.fn;
    const config = this.config;
    if (typeof option === 'function') {
      callback = option;
      option = null;
    }
    option = option || {};
    if (!callback) {
      callback = (error_, ret) => {
        let error = error_;
        if (error) {
          if (!(error instanceof Error)) {
            error = new Error(error);
          }
          throw error;
        }
        html = ret;
      };
    }
    let name = this.config.name;
    if (!name && fn && fn.TPL_NAME) {
      name = fn.TPL_NAME;
    }
    let scope;
    if (data instanceof Scope) {
      scope = data;
    } else {
      scope = new Scope(data);
    }
    const buffer = new LinkedBuffer(callback, config).head;
    const tpl = new TplWrap(name, {
      commands: option.commands
    }, this, scope, buffer, name, fn);
    buffer.tpl = tpl;
    if (!fn) {
      config.loader.load(tpl, (err, fn2) => {
        if (fn2) {
          tpl.fn = this.fn = fn2;
          renderTpl(tpl);
        } else if (err) {
          buffer.error(err);
        }
      });
      return html;
    }
    renderTpl(tpl);
    return html;
  }
};

module.exports = XTemplateRuntime;

/**
 * @ignore
 *
 * 2012-09-12 yiminghe@gmail.com
 *  - 参考 velocity, 扩充 ast
 *  - Expression/ConditionalOrExpression
 *  - EqualityExpression/RelationalExpression...
 *
 * 2012-09-11 yiminghe@gmail.com
 *  - 初步完成，添加 tc
 *
 * 对比 template
 *
 *  优势
 *      - 不会莫名其妙报错（with）
 *      - 更多出错信息，直接给出行号
 *      - 更容易扩展 command, sub-tpl
 *      - 支持子模板
 *      - 支持作用域链: ..\x ..\..\y
 *      - 内置 escapeHtml 支持
 *      - 支持预编译
 *      - 支持简单表达式 +-/%* ()
 *      - 支持简单比较 === !===
 *      - 支持类似函数的嵌套命令
 *   劣势
 *      - 不支持完整 js 语法
 */

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * native commands for xtemplate.
 */

const Scope = __webpack_require__(1);
const util = __webpack_require__(0);
const commands = {
  // range(start, stop, [step])
  range(scope, option) {
    const params = option.params;
    const start = params[0];
    const end = params[1];
    let step = params[2];
    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {
      if (typeof start !== 'number' || typeof end !== 'number' || step && typeof step !== 'number') {
        throw new Error('start/end/step of range must be type number!');
      }
    }
    if (!step) {
      step = start > end ? -1 : 1;
    } else if (start > end && step > 0 || start < end && step < 0) {
      step = -step;
    }
    const ret = [];
    for (let i = start; start < end ? i < end : i > end; i += step) {
      ret.push(i);
    }
    return ret;
  },

  void() {
    return undefined;
  },

  foreach(scope, option, buffer_) {
    let buffer = buffer_;
    const params = option.params;
    const param0 = params[0];
    const xindexName = params[2] || 'xindex';
    const valueName = params[1];
    let xcount;
    let opScope;
    let affix;
    let xindex;
    if (param0) {
      xcount = param0.length;
      for (xindex = 0; xindex < xcount; xindex++) {
        opScope = new Scope(param0[xindex], {
          xcount,
          xindex
        }, scope);
        affix = opScope.affix;
        if (xindexName !== 'xindex') {
          affix[xindexName] = xindex;
          affix.xindex = undefined;
        }
        if (valueName) {
          affix[valueName] = param0[xindex];
        }
        buffer = option.fn(opScope, buffer);
      }
    }
    return buffer;
  },

  forin(scope, option, buffer_) {
    let buffer = buffer_;
    const params = option.params;
    const param0 = params[0];
    const xindexName = params[2] || 'xindex';
    const valueName = params[1];
    let opScope;
    let affix;
    let name;
    // if undefined, will emit warning by compiler
    if (param0) {
      for (name in param0) {
        if (param0.hasOwnProperty(name)) {
          opScope = new Scope(param0[name], {
            xindex: name
          }, scope);
          affix = opScope.affix;
          if (xindexName !== 'xindex') {
            affix[xindexName] = name;
            affix.xindex = undefined;
          }
          if (valueName) {
            affix[valueName] = param0[name];
          }
          buffer = option.fn(opScope, buffer);
        }
      }
    }
    return buffer;
  },

  each(scope, option, buffer) {
    const params = option.params;
    const param0 = params[0];
    if (param0) {
      if (util.isArray(param0)) {
        return commands.foreach(scope, option, buffer);
      }
      return commands.forin(scope, option, buffer);
    }
    return buffer;
  },

  'with'(scope, option, buffer_) {
    let buffer = buffer_;
    const params = option.params;
    const param0 = params[0];
    if (param0) {
      // skip object check for performance
      const opScope = new Scope(param0, undefined, scope);
      buffer = option.fn(opScope, buffer);
    }
    return buffer;
  },

  'if'(scope, option, buffer_) {
    let buffer = buffer_;
    const params = option.params;
    const param0 = params[0];
    if (param0) {
      const fn = option.fn;
      if (fn) {
        buffer = fn(scope, buffer);
      }
    } else {
      let matchElseIf = false;
      const elseIfs = option.elseIfs;
      const inverse = option.inverse;
      if (elseIfs) {
        for (let i = 0, len = elseIfs.length; i < len; i++) {
          const elseIf = elseIfs[i];
          matchElseIf = elseIf.test(scope);
          if (matchElseIf) {
            buffer = elseIf.fn(scope, buffer);
            break;
          }
        }
      }
      if (!matchElseIf && inverse) {
        buffer = inverse(scope, buffer);
      }
    }
    return buffer;
  },

  set(scope_, option, buffer) {
    let scope = scope_;
    const hash = option.hash;
    const len = hash.length;
    for (let i = 0; i < len; i++) {
      const h = hash[i];
      const parts = h.key;
      let depth = h.depth;
      const value = h.value;
      if (parts.length === 1) {
        const root = scope.root;
        while (depth && root !== scope) {
          scope = scope.parent;
          --depth;
        }
        scope.set(parts[0], value);
      } else {
        const last = scope.resolve(parts.slice(0, -1), depth);
        if (last) {
          last[parts[parts.length - 1]] = value;
        }
      }
    }
    return buffer;
  },

  include: 1,

  includeOnce: 1,

  parse: 1,

  extend: 1,

  block(scope, option, buffer_) {
    let buffer = buffer_;
    const self = this;
    const runtime = self.runtime;
    const params = option.params;
    let blockName = params[0];
    let type;
    if (params.length === 2) {
      type = params[0];
      blockName = params[1];
    }
    const blocks = runtime.blocks = runtime.blocks || {};
    const head = blocks[blockName];
    let cursor;
    const current = {
      fn: option.fn,
      type
    };
    if (!head) {
      blocks[blockName] = current;
    } else if (head.type) {
      if (head.type === 'append') {
        current.next = head;
        blocks[blockName] = current;
      } else if (head.type === 'prepend') {
        let prev;
        cursor = head;
        while (cursor && cursor.type === 'prepend') {
          prev = cursor;
          cursor = cursor.next;
        }
        current.next = cursor;
        prev.next = current;
      }
    }

    if (!runtime.extendTpl) {
      cursor = blocks[blockName];
      while (cursor) {
        if (cursor.fn) {
          buffer = cursor.fn.call(self, scope, buffer);
        }
        cursor = cursor.next;
      }
    }

    return buffer;
  },

  macro(scope, option, buffer_) {
    let buffer = buffer_;
    const hash = option.hash;
    const params = option.params;
    const macroName = params[0];
    const params1 = params.slice(1);
    const self = this;
    const runtime = self.runtime;
    const macros = runtime.macros = runtime.macros || {};
    const macro = macros[macroName];
    // definition
    if (option.fn) {
      macros[macroName] = {
        paramNames: params1,
        hash,
        fn: option.fn
      };
    } else if (macro) {
      const paramValues = macro.hash || {};
      const paramNames = macro.paramNames;
      if (paramNames) {
        for (let i = 0, len = paramNames.length; i < len; i++) {
          const p = paramNames[i];
          paramValues[p] = params1[i];
        }
      }
      if (hash) {
        for (const h in hash) {
          if (hash.hasOwnProperty(h)) {
            paramValues[h] = hash[h];
          }
        }
      }
      const newScope = new Scope(paramValues);
      // https://github.com/xtemplate/xtemplate/issues/29
      newScope.root = scope.root;
      // no caller Scope
      buffer = macro.fn.call(self, newScope, buffer);
    } else {
      const error = `can not find macro: ${macroName}`;
      buffer.error(error);
    }
    return buffer;
  }
};

commands.debugger = function debuggerFn() {
  util.globalEval('debugger');
};

module.exports = commands;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * LinkedBuffer of generate content from xtemplate
 */
const util = __webpack_require__(0);

function Buffer(list, next, tpl) {
  this.list = list;
  this.init();
  this.next = next;
  this.ready = false;
  // tpl belongs
  this.tpl = tpl;
}

Buffer.prototype = {
  constructor: Buffer,

  isBuffer: 1,

  init() {
    this.data = '';
  },

  append(data) {
    this.data += data;
    return this;
  },

  write(data) {
    // ignore null or undefined
    if (data !== null && data !== undefined) {
      if (data.isBuffer) {
        return data;
      }
      this.data += data;
    }
    return this;
  },

  writeEscaped(data) {
    // ignore null or undefined
    if (data !== null && data !== undefined) {
      if (data.isBuffer) {
        return data;
      }
      this.data += util.escapeHtml(data);
    }
    return this;
  },

  insert() {
    const self = this;
    const list = self.list;
    const tpl = self.tpl;
    const nextFragment = new Buffer(list, self.next, tpl);
    const asyncFragment = new Buffer(list, nextFragment, tpl);
    self.next = asyncFragment;
    self.ready = true;
    return asyncFragment;
  },

  async(fn) {
    const asyncFragment = this.insert();
    const nextFragment = asyncFragment.next;
    fn(asyncFragment);
    return nextFragment;
  },

  error(e_) {
    const callback = this.list.callback;
    let e = e_;
    if (callback) {
      const tpl = this.tpl;
      if (tpl) {
        if (!(e instanceof Error)) {
          e = new Error(e);
        }
        const name = tpl.name;
        const line = tpl.pos.line;
        const errorStr = `XTemplate error in file: ${name} at line ${line}: `;
        try {
          // phantomjs
          e.stack = errorStr + e.stack;
          e.message = errorStr + e.message;
        } catch (e2) {
          // empty
        }
        e.xtpl = {
          pos: {
            line
          },
          name
        };
      }
      this.list.callback = null;
      callback(e, undefined);
    }
  },

  end() {
    const self = this;
    if (self.list.callback) {
      self.ready = true;
      self.list.flush();
    }
    return self;
  }
};

function LinkedBuffer(callback, config) {
  const self = this;
  self.config = config;
  self.head = new Buffer(self, undefined);
  self.callback = callback;
  this.init();
}

LinkedBuffer.prototype = {
  constructor: LinkedBuffer,

  init() {
    this.data = '';
  },

  append(data) {
    this.data += data;
  },

  end() {
    this.callback(null, this.data);
    this.callback = null;
  },

  flush() {
    const self = this;
    let fragment = self.head;
    while (fragment) {
      if (fragment.ready) {
        this.data += fragment.data;
      } else {
        self.head = fragment;
        return;
      }
      fragment = fragment.next;
    }
    self.end();
  }
};

LinkedBuffer.Buffer = Buffer;

module.exports = LinkedBuffer;

/**
 * 2014-06-19 yiminghe@gmail.com
 * string concat is faster than array join: 85ms<-> 131ms
 */

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 7 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ })
/******/ ]);
});